package errors

import (
	"github.com/diamondburned/arikawa/discord"
	"github.com/mavolin/disstate/pkg/state"

	"github.com/mavolin/adam/pkg/localization"
	"github.com/mavolin/adam/pkg/plugin"
	"github.com/mavolin/adam/pkg/utils/embedutil"
)

// UserError is an error on the user-side.
// The user will reported via a message containing a detailed description of
// the problem.
// The error won't be logged or captured by sentry.
type UserError struct {
	// description of the error, either is set
	descString string
	descConfig localization.Config

	// used just for fields
	fields *embedutil.Builder
}

// NewUserError creates a new UserError with the passed description.
// The description mustn't be empty for this error to be handled properly.
func NewUserError(desc string) *UserError {
	return &UserError{
		descString: desc,
		fields:     embedutil.NewBuilder(),
	}
}

// NewUserErrorl creates a new UserError using the message generated from the
// passed localization.Config as description.
func NewUserErrorl(description localization.Config) *UserError {
	return &UserError{
		descConfig: description,
		fields:     embedutil.NewBuilder(),
	}
}

// NewUserErrorlt creates a new UserError using the message generated from the
// passed term as description.
func NewUserErrorlt(description localization.Term) *UserError {
	return NewUserErrorl(description.AsConfig())
}

// WithField adds the passed field to the error, and returns a pointer to the
// UserError to allow chaining.
// Name or value may be empty, in which case the field won't have a name or
// value.
func (e *UserError) WithField(name, value string) *UserError {
	e.fields.WithField(name, value)
	return e
}

// WithFieldl adds the passed field to the error, and returns a pointer to the
// UserError to allow chaining.
// Name or value may be empty, in which case the field won't have a name or
// value.
func (e *UserError) WithFieldl(name, value localization.Config) *UserError {
	e.fields.WithFieldl(name, value)
	return e
}

// WithFieldlt adds the passed field to the error, and returns a pointer to the
// UserError to allow chaining.
// Name or value may be empty, in which case the field won't have a name or
// value.
func (e *UserError) WithFieldlt(name, value localization.Term) *UserError {
	return e.WithFieldl(name.AsConfig(), value.AsConfig())
}

// WithField adds the passed inlined field to the error, and returns a pointer
// to the UserError to allow chaining.
// Name or value may be empty, in which case the field won't have a name or
// value.
func (e *UserError) WithInlinedField(name, value string) *UserError {
	e.fields.WithInlinedField(name, value)
	return e
}

// WithFieldl adds the passed inlined field to the error, and returns a pointer
// to the UserError to allow chaining.
// Name or value may be empty, in which case the field won't have a name or
// value.
func (e *UserError) WithInlinedFieldl(name, value localization.Config) *UserError {
	e.fields.WithInlinedFieldl(name, value)
	return e
}

// WithFieldlt adds the passed inlined field to the error, and returns a
// pointer to the UserError to allow chaining.
// Name or value may be empty, in which case the field won't have a name or
// value.
func (e *UserError) WithInlinedFieldlt(name, value localization.Term) *UserError {
	return e.WithFieldl(name.AsConfig(), value.AsConfig())
}

// Description returns the description of the error and localizes it, if
// possible.
// Name or value may be empty, in which case the field won't have a name or
// value.
func (e *UserError) Description(l *localization.Localizer) (string, error) {
	if e.descString != "" {
		return e.descString, nil
	}

	return l.Localize(e.descConfig)
}

// Fields returns the discord.EmbedFields of the UserError.
// This can be safely ignored, if only used for errors generated by adam, as
// these will never have fields.
func (e *UserError) Fields(l *localization.Localizer) ([]discord.EmbedField, error) {
	embed, err := e.fields.Build(l)
	if err != nil {
		return nil, err
	}

	return embed.Fields, nil
}

func (e *UserError) Error() string { return "user error" }

// Handle sends an error embed with the description of the UserError.
func (e *UserError) Handle(_ *state.State, ctx *plugin.Context) error {
	desc, err := e.Description(ctx.Localizer)
	if err != nil {
		return err
	}

	embed, err := ErrorEmbed.Clone().
		WithDescription(desc).
		Build(ctx.Localizer)
	if err != nil {
		return err
	}

	fields, err := e.Fields(ctx.Localizer)
	if err != nil {
		return err
	}

	embed.Fields = fields

	_, err = ctx.ReplyEmbed(embed)
	return err
}
